#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include "save_manager.h"

#define SAVE_TRANSFER_BUFFER_SIZE (1024 * 1024)

static u8* transfer_buffer = NULL;
static FsSaveDataInfoReader save_reader;
static FsSaveDataFilter save_filter;

static Result initialize_transfer_buffer(void) {
    if (!transfer_buffer) {
        transfer_buffer = (u8*)malloc(SAVE_TRANSFER_BUFFER_SIZE);
        if (!transfer_buffer) return -1;
    }
    return 0;
}

static Result open_save_reader(void) {
    memset(&save_filter, 0, sizeof(save_filter));
    save_filter.spaceId = FsSaveDataSpaceId_User;
    return fsOpenSaveDataInfoReader(&save_reader, save_filter.spaceId);
}

static void close_save_reader(void) {
    fsSaveDataInfoReaderClose(&save_reader);
}

Result mount_save_data(FsFileSystem* out, u64 title_id) {
    Result rc = 0;
    
    // Find the save data for this title
    FsSaveDataInfo info = {0};
    s64 total_entries = 0;
    
    rc = open_save_reader();
    if (R_FAILED(rc)) return rc;
    
    while (true) {
        rc = fsSaveDataInfoReaderRead(&save_reader, &info, 1, &total_entries);
        if (R_FAILED(rc) || total_entries == 0) break;
        
        if (info.application_id == title_id) {
            FsSaveDataAttribute attr = {
                .application_id = title_id,
                .uid = info.uid,
                .save_data_type = FsSaveDataType_Account,
                .system_save_data_id = info.system_save_data_id
            };
            rc = fsOpenSaveDataFileSystem(out, FsSaveDataSpaceId_User, &attr);
            break;
        }
    }
    
    close_save_reader();
    return rc;
}

Result save_backup_title(u64 title_id, const char* backup_path,
                      void (*progress_cb)(const char* status, size_t current, size_t total)) {
    Result rc = 0;
    FsFileSystem save_fs;
    
    // Initialize transfer buffer
    rc = initialize_transfer_buffer();
    if (R_FAILED(rc)) return rc;
    
    // Mount save data
    rc = mount_save_data(&save_fs, title_id);
    if (R_FAILED(rc)) return rc;
    
    // Create backup directory
    char save_path[PATH_MAX];
    snprintf(save_path, PATH_MAX, "%s/%016lx", backup_path, title_id);
    mkdir(save_path, 0777);
    
    if (progress_cb) {
        progress_cb("Creating backup directory", 0, 1);
    }
    
    // Open save directory
    FsDir dir;
    rc = fsFsOpenDirectory(&save_fs, "/", FsDirOpenMode_ReadFiles | FsDirOpenMode_ReadDirs, &dir);
    if (R_FAILED(rc)) {
        fsFsClose(&save_fs);
        return rc;
    }
    
    // Read directory entries
    s64 total_entries = 0;
    FsDirectoryEntry dir_entry;
    while (true) {
        rc = fsDirRead(&dir, &total_entries, 1, &dir_entry);
        if (R_FAILED(rc) || total_entries == 0) break;
        
        char src_path[PATH_MAX];
        char dst_path[PATH_MAX];
        snprintf(src_path, PATH_MAX, "/%s", dir_entry.name);
        snprintf(dst_path, PATH_MAX, "%s/%s", save_path, dir_entry.name);
        
        if (progress_cb) {
            progress_cb(dir_entry.name, 0, 1);
        }
        
        if (dir_entry.type == FsDirEntryType_Dir) {
            // Create directory
            mkdir(dst_path, 0777);
        } else {
            // Copy file
            FsFile src_file;
            rc = fsFsOpenFile(&save_fs, src_path, FsOpenMode_Read, &src_file);
            if (R_FAILED(rc)) continue;
            
            FILE* dst = fopen(dst_path, "wb");
            if (!dst) {
                fsFileClose(&src_file);
                continue;
            }
            
            s64 file_size;
            rc = fsFileGetSize(&src_file, &file_size);
            if (R_SUCCEEDED(rc)) {
                s64 offset = 0;
                u64 bytes_read = 0;
                while (offset < file_size) {
                    size_t read_size = file_size - offset > SAVE_TRANSFER_BUFFER_SIZE ? 
                                     SAVE_TRANSFER_BUFFER_SIZE : file_size - offset;
                    
                    rc = fsFileRead(&src_file, offset, transfer_buffer, read_size, 0, &bytes_read);
                    if (R_FAILED(rc)) break;
                    
                    if (fwrite(transfer_buffer, 1, bytes_read, dst) != bytes_read) {
                        rc = -1;
                        break;
                    }
                    
                    offset += bytes_read;
                    if (progress_cb) {
                        progress_cb(dir_entry.name, offset, file_size);
                    }
                }
            }
            
            fclose(dst);
            fsFileClose(&src_file);
        }
    }
    
    fsDirClose(&dir);
    fsFsClose(&save_fs);
    
    if (progress_cb) {
        progress_cb("Backup complete", 1, 1);
    }
    return rc;
}

Result save_restore_title(u64 title_id, const char* backup_path,
                       void (*progress_cb)(const char* status, size_t current, size_t total)) {
    Result rc = 0;
    FsFileSystem save_fs;
    
    // Initialize transfer buffer
    rc = initialize_transfer_buffer();
    if (R_FAILED(rc)) return rc;
    
    // Mount save data
    rc = mount_save_data(&save_fs, title_id);
    if (R_FAILED(rc)) return rc;
    
    char save_path[PATH_MAX];
    snprintf(save_path, PATH_MAX, "%s/%016lx", backup_path, title_id);
    
    if (progress_cb) {
        progress_cb("Checking backup", 0, 1);
    }
    
    // Verify backup exists
    struct stat st;
    if (stat(save_path, &st) != 0 || !S_ISDIR(st.st_mode)) {
        fsFsClose(&save_fs);
        return -1;
    }
    
    // Open backup directory
    DIR* dir = opendir(save_path);
    if (!dir) {
        fsFsClose(&save_fs);
        return -2;
    }
    
    if (progress_cb) {
        progress_cb("Starting restore", 0, 1);
    }
    
    // Read directory entries
    struct dirent* ent;
    while ((ent = readdir(dir)) != NULL) {
        if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) 
            continue;
        
        char src_path[PATH_MAX];
        char dst_path[PATH_MAX];
        snprintf(src_path, PATH_MAX, "%s/%s", save_path, ent->d_name);
        snprintf(dst_path, PATH_MAX, "/%s", ent->d_name);
        
        if (progress_cb) {
            progress_cb(ent->d_name, 0, 1);
        }
        
        if (ent->d_type == DT_DIR) {
            // Create directory in save
            rc = fsFsCreateDirectory(&save_fs, dst_path);
            if (R_FAILED(rc)) continue;
        } else {
            // Copy file to save
            FILE* src = fopen(src_path, "rb");
            if (!src) continue;
            
            struct stat file_st;
            if (stat(src_path, &file_st) != 0) {
                fclose(src);
                continue;
            }
            
            FsFile dst_file;
            rc = fsFsCreateFile(&save_fs, dst_path, 0, 0);
            if (R_SUCCEEDED(rc)) {
                rc = fsFsOpenFile(&save_fs, dst_path, FsOpenMode_Write, &dst_file);
                if (R_SUCCEEDED(rc)) {
                    s64 offset = 0;
                    size_t bytes_read;
                    while ((bytes_read = fread(transfer_buffer, 1, SAVE_TRANSFER_BUFFER_SIZE, src)) > 0) {
                        rc = fsFileWrite(&dst_file, offset, transfer_buffer, bytes_read, 0);
                        if (R_FAILED(rc)) break;
                        offset += bytes_read;
                        
                        if (progress_cb) {
                            progress_cb(ent->d_name, offset, file_st.st_size);
                        }
                    }
                    
                    rc = fsFileFlush(&dst_file);
                    fsFileClose(&dst_file);
                }
            }
            
            fclose(src);
        }
    }
    
    closedir(dir);
    fsFsClose(&save_fs);
    
    if (progress_cb) {
        progress_cb("Restore complete", 1, 1);
    }
    return rc;
}

Result save_backup_all(const char* backup_path) {
    Result rc = 0;
    FsSaveDataInfo info = {0};
    
    // Open save data reader
    rc = open_save_reader();
    if (R_FAILED(rc)) return rc;
    
    // Iterate through all saves
    s64 total_entries = 0;
    while (R_SUCCEEDED(rc)) {
        rc = fsSaveDataInfoReaderRead(&save_reader, &info, 1, &total_entries);
        if (R_FAILED(rc) || total_entries == 0) break;
        
        rc = save_backup_title(info.application_id, backup_path);
        if (R_FAILED(rc)) break;
    }
    
    close_save_reader();
    return rc;
}

Result save_restore_all(const char* backup_path) {
    Result rc = 0;
    DIR* dir = opendir(backup_path);
    if (!dir) return -1;
    
    struct dirent* ent;
    while ((ent = readdir(dir))) {
        if (ent->d_type == DT_DIR && strlen(ent->d_name) == 16) {
            // Convert directory name to title ID
            u64 title_id = strtoull(ent->d_name, NULL, 16);
            rc = save_restore_title(title_id, backup_path);
            if (R_FAILED(rc)) break;
        }
    }
    
    closedir(dir);
    return rc;
}

Result save_list_titles(char*** out_titles, int* out_count) {
    Result rc = 0;
    FsSaveDataInfo info = {0};
    
    // Count titles first
    rc = open_save_reader();
    if (R_FAILED(rc)) return rc;
    
    s64 total_entries = 0;
    int count = 0;
    while (R_SUCCEEDED(rc)) {
        rc = fsSaveDataInfoReaderRead(&save_reader, &info, 1, &total_entries);
        if (R_FAILED(rc) || total_entries == 0) break;
        count++;
    }
    
    close_save_reader();
    
    // Allocate memory for titles
    char** titles = (char**)malloc(count * sizeof(char*));
    if (!titles) {
        return -1;
    }
    
    // Reset reader and fill titles
    rc = open_save_reader();
    if (R_SUCCEEDED(rc)) {
        int i = 0;
        while (R_SUCCEEDED(rc) && i < count) {
            rc = fsSaveDataInfoReaderRead(&save_reader, &info, 1, &total_entries);
            if (R_FAILED(rc) || total_entries == 0) break;
            
            titles[i] = (char*)malloc(256);
            if (titles[i]) {
                save_get_title_name(info.application_id, titles[i], 256);
            }
            i++;
        }
        
        close_save_reader();
    }
    
    *out_titles = titles;
    *out_count = count;
    return rc;
}

Result save_get_title_name(u64 title_id, char* out_name, size_t name_size) {
    Result rc = 0;
    NsApplicationControlData control_data = {0};
    size_t control_size = 0;
    
    rc = nsGetApplicationControlData(NsApplicationControlSource_Storage, title_id, &control_data, sizeof(control_data), &control_size);
    if (R_SUCCEEDED(rc)) {
        strncpy(out_name, control_data.nacp.lang[0].name, name_size - 1);
    } else {
        snprintf(out_name, name_size, "%016lx", title_id);
    }
    
    return rc;
}